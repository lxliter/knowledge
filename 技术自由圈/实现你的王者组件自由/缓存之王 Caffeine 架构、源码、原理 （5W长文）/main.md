## 缓存之王 Caffeine 架构、源码、原理 （5W长文）

### 高性能核心组件穿透的意义
要想成为高手，就要 彻底的掌握  那些 顶级组件、王者组件。
***从王者组件中吸取思想和精华， 为大家自己的业务CRUD所用***。
唯有如此，才能成为技术王者。
接下来，和尼恩一起，开始王者组件的学习、研究、穿透之旅吧：
- 高性能核心组件之1： 
穿透“IO之王  Netty ” 架构和源码
- 穿透高性能核心组件之2：
“队列之王 Disruptor” 架构和源码（Disruptor 红宝书）
- 穿透高性能核心组件之3：
穿透“缓存之王 Caffeine” 架构和源码（Caffeine  红宝书）
- 穿透高性能核心组件之4：
穿透“链路之王  Skywalking ” 架构和源码
此文，带大家 穿透高性能核心组件之3 ：
穿透“缓存之王 Caffeine” 架构和源码
所以，此文又名为: Caffeine  红宝书

### 本地缓存的使用场景

#### 场景1：突发性hotkey场景
突发性hotkey导致的分布式缓存性能变差、缓存击穿的场景

##### 什么是热Key
在某段时间内某个key收到的访问次数，显著高于其他key时，我们可以将其称之为热key。
例如，某redis的每秒访问总量为10000，而其中某个key的每秒访问量达到了7000，这种情况下，我们称该key为热key。

##### 热key带来的问题
1. 热Key占用大量的Redis CPU时间使其性能变差并影响其它请求；
2. Redis Cluster中各node流量不均衡，造成Redis Cluster的分布式优势无法被Client利用，
一个分片负载很高，而其它分片十分空闲从而产生读/写热点问题；
3. 热Key的请求压力数量超出Redis的承受能力造成缓存击穿，此时大量请求将直接指向后端存储将其打挂并影响到其它业务；

##### 热key出现的典型业务
预期外的访问量陡增，如***突然出现的爆款商品***，***访问量暴涨的热点新闻***，***直播间某大主播搞活动大量的刷屏点赞***。

##### 解决方案
通过分布式计算来探测热点key，
分布式计算组件，计算出来之后， 并通知集群内其他机器。
***其他机器，本地缓存HotKey***，

#### 场景2：常规性hotkey场景
部门组织机构数据
人员类型数据

##### 解决方案
本地缓存HotKey，
***通过发布订阅解决数据一致性问题***

### 本地缓存的主要技术
Java缓存技术可分为分布式缓存和本地缓存，分布式缓存在后面的 100Wqps 三级缓存组件中，再细致介绍。
先看本地缓存。
本地缓存的代表技术主要有HashMap，Guava Cache，Caffeine和EHCache。

- HashMap <br>
通过Map的底层方式，直接将需要缓存的对象放在内存中。<br>
优点：简单粗暴，不需要引入第三方包，比较适合一些比较简单的场景。<br>
缺点：没有缓存淘汰策略，定制化开发成本高。

- Guava Cache <br>
Guava Cache是由Google开源的基于LRU替换算法的缓存技术。 <br>
但Guava Cache由于被下面即将介绍的Caffeine全面超越而被取代。 <br>
优点：支持最大容量限制，两种过期删除策略（插入时间和访问时间），支持简单的统计功能。 <br>
缺点：springboot2和spring5都放弃了对Guava Cache的支持。 <br>

- Caffeine <br>
Caffeine采用了W-TinyLFU（LRU和LFU的优点结合）开源的缓存技术。 <br>
缓存性能接近理论最优，属于是Guava Cache的增强版。 <br>

- EHCache <br>
EHCache是一个纯java的进程内缓存框架，具有快速、精干的特点。 <br>
是hibernate默认的cacheprovider。<br>
优点：<br>
支持多种缓存淘汰算法，包括LFU，LRU和FIFO；<br>
缓存支持堆内缓存，堆外缓存和磁盘缓存；<br>
支持多种集群方案，解决数据共享问题。<br>

> 说明：本文会分析 Caffeine的源码，后面可以对照分析一下 Guava Cache的源码。

### 本地缓存的优缺点
1. 快但是量少：访问速度快，但无法进行大数据存储，
本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，
但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。

2. 需要解决数据一致性问题：集群的数据更新问题，
与此同时，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，
如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来保证数据一致性，
复杂度较高并且容易出错，如***基于rocketmq的发布订阅机制来同步更新各个部署节点***。

3. 更新低可靠，容易丢失： 数据随应用进程的重启而丢失，
由于本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。
所以对于需要更改然后持久化的数据，需要注意及时保存，否则可能会造成数据丢失。

### 和缓存相关的几个核心概念
#### 缓存污染
缓存污染，指留存在缓存中的数据，实际不会被再次访问了，但又占据了缓存空间。
换句话说，由于缓存空间有限，热点数据被置换或者驱逐出去了，而一些后面不用到的数据却反而被留下来，从而缓存数据命中率急剧下降，
要解决缓存污染的关键点是能识别出热点数据，或者未来更有可能被访问到的数据。
换句话说: ***是要提升缓存数据命中率***

#### 缓存命中率
缓存命中率是一个缓存组件是否好用的核心指标之一，***而命中率又和缓存组件本身的缓存数据淘汰算法息息相关***。
命中：可以直接通过缓存获取到需要的数据。
不命中：无法直接通过缓存获取到想要的数据，需要再次查询数据库或者执行其它的操作。原因可能是由于缓存中根本不存在，或者缓存已经过期。
通常来讲，缓存的命中率越高则表示使用缓存的收益越高，***应用的性能越好（响应时间越短、吞吐量越高），抗并发的能力越强***。
由此可见，在高并发的互联网系统中，缓存的命中率是至关重要的指标。
而 缓存的命中率 的提升，和 缓存数据淘汰算法 ,  密切相关。



































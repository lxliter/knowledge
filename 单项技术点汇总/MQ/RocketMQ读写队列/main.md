## RocketMQ读写队列

### 读写队列作用
RocketMQ创建Topic时，可以配置writeQueueNums和readQueueNums，***读写队列，是在做路由信息时使用***。
- writeQueueNums
- readQueueNums

在消息发送时，使用写队列个数返回路由信息，而消息消费时按照读队列个数返回路由信息。
在物理文件层面，只有写队列才会创建文件。

写队列个数是8，设置的读队列个数是4，这个时候，会创建8个文件夹，代表0 1 2 3 4 5 6 7，
但在消息消费时，路由信息只返回4，在具体拉取消息时，就只会消费0 1 2 3这4个队列中的消息，
4 5 6 7中的信息压根就不会被消费。
反过来，如果写队列个数是4，读队列个数是8，在生产消息时只会往0 1 2 3中生产消息，
消费消息时则会从0 1 2 3 4 5 6 7所有的队列中消费，当然 4 5 6 7中压根就没有消息 。

***readQueueNums>=writeQueueNums,程序才能正常进行***
最佳实践是readQueueNums=writeQueueNums。那rocketmq为什么要区分读写队列呢？
直接强制readQueueNums=writeQueueNums，不就没有问题了吗？
rocketmq设置读写队列数的目的在于方便队列的缩容和扩容。

- rocketmq设置读写队列数的目的在于方便队列的缩容和扩容

假如一个topic在每个broker上创建了128个队列，现在需要将队列缩容到64个，
怎么做才能100%不会丢失消息，并且无需重启应用程序？最佳实践：先缩容写队列128->64，
写队列由0 1 2 ......127缩至 0 1 2 ........63。等到64 65 66......127中的消息全部消费完后，
再缩容读队列128->64(同时缩容写队列和读队列可能会导致部分消息未被消费)。





















